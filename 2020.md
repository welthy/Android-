[TOC]
## **Android**
### **FrameWork**
#### **IPC**
##### **说说binder机制的原理**
Binder由4部分组成：Server，Client，ServiceManager和Binder驱动。
Server：服务端。负责功能的具体实现；
Client：客户端。功能的调用方；
ServiceManager：类似于DNS，根据Client调用的服务名找到对应的Binder引用并返回给Client；
Binder驱动：类似于路由，实现进程间通信，负责Binder线程管理等。

Binder通信分为如下几步：
- Server端首先向ServiceManager注册，SMgr收到注册消息后，将其对应的名称与Binder引用存储于Map中。
- Client向SMgr发起请求，获取Server的引用。SMgr根据收到的参数查找到对应的Server端引用返回给Client，Client收到后就建立了Client与Server间的通信通道
- Client传入特定参数给Binder驱动，Binder驱动申请一定大小的内核内存空间，并与内核接收缓存及Server用户空间的接收缓存区进行内存映射。Client线程将参数传递给内核空间的接收缓存区后，线程就挂起。由于内存映射，相当于直接传递给了Server端，Server中的分配线程解析包并调用其中的方法，执行完后将结果封装到数据包中，根据内存映射传递回内核接收缓存区。Binder驱动唤醒Client线程，并传递返回的数据包，Client收到数据包后获取结果，至此完成IPC通信。



##### **android跨进程通信了解吗？共享内存用过吗？binder怎么验证pid?binder驱动了解吗？**  
Binder数据传输时会将调用方的pid和uid封装到数据包中，Server可以通过getCallingPid()/getCallingUid()获取到调用方的pid或uid，然后进行特定的校验。  
也可以通过Binder.clearCallingIndenity()清除调用方的uid/pid。  
可以清除也可以通过Binder.restoreCallingIndentity(token)恢复调用方的uid/pid


##### **binder进程间通信可以调用原进程方法吗？**  
可以，相当于Client已知Server端的引用，无需通过SMgr就有通信通道。

##### **AIDL in out oneWay代表什么意思？**  
- in：只允许数据向Server输入；
- out：只允许数据从Server输出；
- inout：数据可从Server输出也可输入；
- oneway：代表方法是异步调用。

##### **跨进程通信了解多少？管道了解吗？**
IPC方式：Socket，信号量，管道，Binder，共享内存


##### **SharedParence可以跨进程通信吗？如何改造成可以跨进程通信的.commit和apply的区别**
默认是不可以跨进程通信，若需要跨进程通信可如下操作：
- 需要通信的应用设置成相同的shareUID；
- 获取数据的应用通过包名，拿的对应的context。然后通过该context拿到SharedPreference实例

commit和apply的区别：
- 两者都是原子操作，但commit是将数据直接写到数据库中，而apply是写到内存中，然后再异步写入到数据库中。
- commit有布尔返回值，apply没有。所以commit可以指定提交结果，而apply无法得知。


#### **Handler**  
##### **Handler问题三连：是什么？有什么用？为什么要用Handler，不用行不行？**  
Handler是Android系统提供给开发者的一种线程间通信的方式。除了Handler，开发者也可以使用其他的线程间通信方式，只不过Google推荐优先使用handler的方式。


##### **真的只能在主(UI)线程中更新UI吗？**  
禁止在子线程中更新UI，是因为子线程UI状态不确定，但可以更新在子线程中创建的UI，这样UI的状态子线程可随时观察到。
另，Android使用的是单线程模式，处理多线程更新UI造成的不可控情况。但可以在onCreate中子线程直接更新UI，但增加耗时则不行，因为在onCreate的时候，ViewRootImpl还未创建，在onResume之后才创建，创建后才会进行checkThread操作。


##### **真的不能在主(UI)线程中执行网络操作吗？** 
可以在关闭StrictMode严苛模式的情况下在主线程执行网络操作


##### **为什么建议使用Message.obtain()来创建Message实例？** 
因为通过Message.obtain()获取Message实例，是从消息池中复用消息实例，避免重复创建浪费资源。

##### **为什么子线程中不可以直接new Handler()而主线程中可以？** 
因为使用Handler需要首先执行Looper.prepare()和Looper.loop()方法，若不执行这些操作是不可以使用Handler的。 
主线程之所以可以直接创建并使用，是因为在ActivityThread中的main方法中已经执行过Looper.prepare()和Looper.loop()方法。

##### **主线程给子线程的Handler发送消息怎么写？**  
handler.sendEmptyMessage()/postXXX()

##### **HandlerThread实现的核心原理？**   
HandlerThread就是已经在子线程中执行了Looper.prepare()和Looper.loop()操作。 而无需开发者手动执行这些操作。

##### **当你用Handler发送一个Message，发生了什么？**   
当用Handler发送消息时，是将该Message入MessageQueue，并同时唤醒Looper.next()阻塞遍历消息队列。

##### **分发给Handler的消息是怎么处理的？**   
Handler将Message入队MessageQueue，入队后唤醒Looper，Looper遍历消息取出消息，然后回调给Handler的handleMessage()接口。

##### **IdleHandler是什么？** 
当MessageQueue中无可处理的消息时会调用IdleHandler。用于处理View的相关事务后的一些额外操作，不会阻塞主线程。如View绘制完成后进行一些额外的处理，如获取宽高，打印log等操作

##### **Looper在主线程中死循环，为啥不会ANR？**   
主线程的各个生命周期也是作为MessageQueue中的消息执行。其本身也是作为消息处理，本身一直处于阻塞中，所以不会ANR。

##### **Handler泄露的原因及正确写法**   
Handler泄漏，是因为Handler持有Activity的引用，而Handler被MessageQueue中的Message所持有，而Message被MessageQueue所持有，所以当执行长时间的消息时，Activity退出由于被持有链中的MessageQueue所持有，仍然是可达的，所以无法被回收掉，造成泄漏。  
此时，可以将Handler作为static静态变量，或者将Activity用弱引用WeakReference包装后再使用。

##### **Handler中的同步屏障机制** 
同步屏障机制其作用是当遍历消息队列时，遇到屏障则会跳过后续的同步消息，找到异步消息并执行。故其可保证异步消息及时执行。同步屏障消息是target为null的消息，但用普通方式入队时会根据target是否等于null的条件给排除掉，所以同步屏障消息入队有特殊的接口postSyncBarrier，使用完后可通过removeSyncBarrier移除屏障消息。

##### **Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？** 
Handler的休眠唤醒机制，是因为Looper是不断循环遍历队列，但若当前无消息需要执行时那么遍历就会浪费资源。故在无消息需要处理时，就阻塞Looper，待到指定时间或有消息需要处理时再唤醒Looper获取消息并处理。 
Handler的休眠唤醒机制是利用linux里的epoll机制，通过epoll_create创建初始化，epoll_ctl注册事件，文件被指定事件触发时则回调，epoll_wait待超过指定时间后执行回调。 
MessageQueue中的消息是根据时间顺序排队的，越早需要执行的消息排在越前。然后调用nativePollOnce方法传入延时时间，此时就会阻塞在此，当阻塞时间到达延时时间时就会被唤醒，取出消息执行。  
移除延时消息时会唤醒线程再遍历一次，重新计算是否要休眠。故之前的休眠会被解除。







#### 四大组件及Fragment的启动相关
##### **Activity启动模式，以及各启动模式生命周期问题** 


##### **Activity怎么启动Service，Activity与Service交互，Service与Thread的区别** 


##### **Launcher启动App的流程，中间有几种跨进程通信(socket)** 



##### **A Activity打开B Activity的生命周期变化，会有什么方法打断吗？** 

##### **Fragment hide show生命周期变化** 


##### **Fragment replace生命周期变化** 

##### **AMS交互调用生命周期是顺序的吗？** 

##### **登陆功能，登陆成功然后跳转到一个新Activity，中间涉及什么？从事件传递，网络请求,AMS交互角度分析** 

##### **广播与RxBus的区别，全局广播与局部广播区别** 

##### **说说App的启动过程,在ActivityThread的main方法里面做了什么事，什么时候启动第一个Activity？** 
##### **onCreate,onResume,onStart里面，什么地方可以获得宽高** 
##### **attachToWindow什么时候调用？** 























## **Java**







